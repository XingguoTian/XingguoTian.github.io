<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="To share something Useful and Meaningful Located in MY mind">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian-Daye on the Way">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Tian-Daye on the Way">
<meta property="og:description" content="To share something Useful and Meaningful Located in MY mind">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tian-Daye on the Way">
<meta name="twitter:description" content="To share something Useful and Meaningful Located in MY mind">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Tian-Daye on the Way</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian-Daye on the Way</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/31/CCP's Implementation Based on Linux Kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xingguo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian-Daye on the Way">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/31/CCP's Implementation Based on Linux Kernel/" itemprop="url">CCP's Implementation Based on Linux Kernel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-31T19:52:11+08:00">
                2019-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Software/" itemprop="url" rel="index">
                    <span itemprop="name">Software</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/31/CCP's Implementation Based on Linux Kernel/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/03/31/CCP's Implementation Based on Linux Kernel/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CCP’s-Implementation-Based-on-Linux-Kernel"><a href="#CCP’s-Implementation-Based-on-Linux-Kernel" class="headerlink" title="CCP’s Implementation Based on Linux Kernel"></a>CCP’s Implementation Based on Linux Kernel</h2><h3 id="CCP-简介"><a href="#CCP-简介" class="headerlink" title="CCP 简介"></a>CCP 简介</h3><p>The congestion control plane (CCP) is a new platform for writing and sharing datapath-agnostic congestion control algorithms. It makes it easy to to program sophisticated algorithms (write Rust or Python in a safe user-space environment as opposed to writing C and a risk of crashing your kernel), and allows the same algorithm implementation to be run on a variety of datapaths (Linux Kernel, DPDK or QUIC).</p>
<h3 id="CCP-整体工作流程梳理"><a href="#CCP-整体工作流程梳理" class="headerlink" title="CCP 整体工作流程梳理"></a>CCP 整体工作流程梳理</h3><ol>
<li><p>新的拥塞控制算法或者拥塞控制架构都是以注册函数的形式注册进内核，Linux 内核提供了注册拥塞控制算法的接口；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  tcp_register_congestion_control(&amp;tcp_ccp_congestion_ops);<span class="comment">//实现注册</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> <span class="title">tcp_ccp_congestion_ops</span> = &#123;</span><span class="comment">//注册内容</span></span><br><span class="line">...</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拥塞控制算法的实现依赖于对网络中相关特性的测量，例如 RTT, Bandwidth, packet loss等元素。如何获取这些元素？以下3个结构体，它们均由内核提供，提供了基本的已经测量完成的测量元素，可以直接从结构体中读出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>；//<span class="title">include</span>/<span class="title">net</span>/<span class="title">sock</span>.<span class="title">h</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">tcp_sock</span>；</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">rate_sample</span>;</span><span class="comment">// include/net/tcp.h</span></span><br></pre></td></tr></table></figure>
<p>以上3个由内核提供的结构体可以提供基本测量元素，例如 bytes_acked, interval_us, rtt_us, losses等。但是，很多时候拥塞控制算法的实现并不单单是使用基本测量元素，而是在基本元素的基础上进行加工而成。举个例子，接受速率或者发送速率需要通过其他基本元素计算出来。CCP针对不同的拥塞控制算法，通过调研，总结出了15种需要测量的元素，又称 primitives，这些元素都是可以通过对socket中的相关数据做简单运算得出来。下列函数实现了该功能。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int load_primitives(struct sock *sk, const struct rate_sample *rs)；//ccp-kernel/tcp_ccp.c</span><br></pre></td></tr></table></figure>
<p>测量结果放在指定的寄存器中。</p>
</li>
<li><p>数据平面和控制平面的通信。控制平面位于用户空间，数据平面位于内核空间；数据平面提供控制平面表征网络状况的的测量元素，控制平面根据某种拥塞控制算法来修改数据平面的 cwnd， pacing rate等特性。控制平面和数据平面通过 netlink进行通信。<br> 3.1 数据平面会计算出所有的可能用到的测量元素，但是传输给控制平面的元素仅是由控制面的拥塞控制算法指定的元素。可以这样简单进行理解，但是实际的实现过程略复杂。<br>注：做如下定义：<br>一级测量元：直接从内核中读取到的测量元素；<br>二级测量元：对一级测量元进行简单加工得到的15种primitives;<br>三级测量元：对二级测量元进行运算而成，具体的运算过程由相应的运算控制算法决定。<br>可以说，控制平面在一定程度上定义了元素的测量方法。  </p>
<p> 3.2 控制平面在算法初始时会将算法需要的测量元素（测量元素的计算方法）告知数据平面，之后会根据数据面传来的测量元素进行决策。</p>
</li>
<li><p>控制平面的决策结果如何在决策面生效？例如，控制平面计算出了cwnd的值，那么如何修改发送端的cwnd值呢？首先，控制面将结果发送给数据面，数据面修改内核提供的结构体来达到修改cwnd的值。关键函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_set_cwnd</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct ccp_datapath *dp,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct ccp_connection *conn, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> cwnd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span>;</span></span><br><span class="line">    get_sock_from_ccp(&amp;sk, conn);</span><br><span class="line">    tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate cwnd value back into packets</span></span><br><span class="line">    cwnd /= tp-&gt;mss_cache;</span><br><span class="line">    tp-&gt;snd_cwnd = cwnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析上述代码可知，控制平面在sock 结构体上修改，数据平面替换掉原来的sock来达到修改cwnd的效果。</p>
</li>
</ol>
<hr>
<h2 id="下文是相关函数的具体分析"><a href="#下文是相关函数的具体分析" class="headerlink" title="下文是相关函数的具体分析"></a>下文是相关函数的具体分析</h2><h4 id="数据平面（Linux-Kernel）代码分析"><a href="#数据平面（Linux-Kernel）代码分析" class="headerlink" title="数据平面（Linux Kernel）代码分析"></a>数据平面（Linux Kernel）代码分析</h4><p><a href="https://www.jianshu.com/p/e58c16c357d6" target="_blank" rel="noopener">参考文献</a>,后面有时间再看。<br>文件定位： tcp_CCP.c     </p>
<ol>
<li><p>通过module_init将当前模块加载进内核；   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_init(tcp_ccp_register);</span><br></pre></td></tr></table></figure>
</li>
<li><p>从tcp_ccp_register函数开启我们的旅程，关键代码： ccp_datapath 和 ccp 之间的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    struct ccp_datapath dp = &#123;</span><br><span class="line">        .set_cwnd = &amp;do_set_cwnd,</span><br><span class="line">        .set_rate_abs = &amp;do_set_rate_abs,</span><br><span class="line">        .set_rate_rel = &amp;do_set_rate_rel,</span><br><span class="line">        .now = &amp;ccp_now,</span><br><span class="line">        .since_usecs = &amp;ccp_since,</span><br><span class="line">        .after_usecs = &amp;ccp_after</span><br><span class="line">    &#125;;</span><br><span class="line">    //Attached: </span><br><span class="line">    struct ccp &#123;</span><br><span class="line">    // control</span><br><span class="line">    u32 last_snd_una; // 4 B</span><br><span class="line">    u32 last_bytes_acked; // 8 B</span><br><span class="line">    u32 last_sacked_out; // 12 B</span><br><span class="line">    struct skb_info *skb_array; // array of future skb information</span><br><span class="line"></span><br><span class="line">    // communication</span><br><span class="line">    struct ccp_connection *dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里只以netlink通信方式进行代码分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if __IPC__ == IPC_NETLINK</span><br><span class="line">    ok = ccp_nl_sk(&amp;ccp_read_msg);//creat a netlink,</span><br><span class="line">    //指定收到消息时的处理函数， 生成立 netlink的socket nl_sk, 一个全局变量， 位于 ccp_nl.cpp文件， </span><br><span class="line">    //struct sock *nl_sk;</span><br><span class="line">    if (ok &lt; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp.send_msg = &amp;nl_sendmsg;//Send serialized message to userspace CCP 指定从kernel发往userspace的发送函数，在ccp_nl.c函数中可以看到具体的发送流程</span><br></pre></td></tr></table></figure></p>
<p>初始化内核内部ccp的框架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ok = ccp_init(&amp;dp);//Initialize gloal state and allocate a map for ccp connections upon module load.</span><br><span class="line">if (ok &lt; 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用内核接口注册新的拥塞控制算法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return tcp_register_congestion_control(&amp;tcp_ccp_congestion_ops);</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>ccp_init 函数： ccp_active_connections、 datapath、 datapath_programs </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">datapath-&gt;set_cwnd           = dp-&gt;set_cwnd;</span><br><span class="line">datapath-&gt;set_rate_abs       = dp-&gt;set_rate_abs;</span><br><span class="line">datapath-&gt;set_rate_rel       = dp-&gt;set_rate_rel;</span><br><span class="line">datapath-&gt;send_msg           = dp-&gt;send_msg;</span><br><span class="line">datapath-&gt;now                = dp-&gt;now;</span><br><span class="line">datapath-&gt;since_usecs        = dp-&gt;since_usecs;</span><br><span class="line">datapath-&gt;after_usecs        = dp-&gt;after_usecs;</span><br><span class="line">datapath-&gt;impl               = dp-&gt;impl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析tcp_ccp_congestion_ops的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct tcp_congestion_ops tcp_ccp_congestion_ops = &#123;</span><br><span class="line">    .flags = TCP_CONG_NEEDS_ECN,</span><br><span class="line">    .in_ack_event = tcp_ccp_in_ack_event,</span><br><span class="line">    .name = &quot;ccp&quot;,</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .init = tcp_ccp_init,</span><br><span class="line">    .release = tcp_ccp_release,</span><br><span class="line">    .ssthresh = tcp_ccp_ssthresh,</span><br><span class="line">    //.cong_avoid = tcp_ccp_cong_avoid,</span><br><span class="line">    .cong_control = tcp_ccp_cong_control,</span><br><span class="line">    .undo_cwnd = tcp_ccp_undo_cwnd,</span><br><span class="line">    .set_state = tcp_ccp_set_state,</span><br><span class="line">    .pkts_acked = tcp_ccp_pkts_acked</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 4.1 进入关键函数’tcp_ccp_cong_control‘进行分析： inet_csk_ca 函数的作用?；<br>该函数调用函数 ccp_invoke， 在这之前先了解一下ccp_priv_state,ccp_connection结构体：     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// libccp Private State  </span><br><span class="line">// struct ccp_connection has a void* state to store libccp&apos;s state  </span><br><span class="line">// libccp internally casts this to a struct ccp_priv_state*</span><br><span class="line">//</span><br><span class="line">struct ccp_priv_state &#123;</span><br><span class="line">    bool sent_create;</span><br><span class="line">    u64 implicit_time_zero; // can be reset</span><br><span class="line"></span><br><span class="line">    u16 program_index; // index into program array</span><br><span class="line">    int staged_program_index;//什么意思？</span><br><span class="line"></span><br><span class="line">    struct register_file registers;</span><br><span class="line">    struct staged_update pending_update;</span><br><span class="line">&#125;;</span><br><span class="line">  /* </span><br><span class="line">   * CCP state per connection. </span><br><span class="line">   * impl is datapath-specific, the rest are internal to libccp</span><br><span class="line">   * for example, the linux kernel datapath uses impl to store a pointer to struct sock</span><br><span class="line">   */</span><br><span class="line">  struct ccp_connection &#123;</span><br><span class="line">      // the index of this array element</span><br><span class="line">      u16 index;</span><br><span class="line"></span><br><span class="line">      u32 last_create_msg_sent;</span><br><span class="line"></span><br><span class="line">      // struct ccp_primitives is large; as a result, we store it inside ccp_connection to avoid</span><br><span class="line">      // potential limitations in the datapath</span><br><span class="line">      // datapath should update this before calling ccp_invoke()</span><br><span class="line">      struct ccp_primitives prims;</span><br><span class="line"></span><br><span class="line">      // constant flow-level information</span><br><span class="line">      struct ccp_datapath_info flow_info;</span><br><span class="line"></span><br><span class="line">      // private libccp state for the send machine and measurement machine</span><br><span class="line">      void *state;</span><br><span class="line"></span><br><span class="line">      // datapath-specific per-connection state</span><br><span class="line">      void *impl;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>4.2 ccp_invoke 函数位于ccp.c文件，分析ccp_invoke函数的执行流程：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Should be called along with the ACK clock.</span><br><span class="line">//will invoke the send and measurement machines.</span><br><span class="line">state = get_ccp_priv_state(conn);//获取connection的state</span><br><span class="line">ok = send_conn_create(datapath, conn);//ccp.c, send create msg, 发送的消息内容，见下文</span><br><span class="line">//至此datapath与userspace建立了连接</span><br></pre></td></tr></table></figure></p>
<p>  4.3 如果已经建立连接，从connnection中取出cwnd， snd_rate的值，放入相关的寄存器。检测相关相关寄存器的状态，impl_is_pending，若为真，写回相应的值.<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> if (state-&gt;pending_update.impl_is_pending[CWND_REG]) &#123;</span><br><span class="line">    DBG_PRINT(&quot;[sid=%d] Applying staged field update: cwnd reg &lt;- %llu\n&quot;, conn-&gt;index, state-&gt;pending_update.impl_registers[CWND_REG]);</span><br><span class="line">    state-&gt;registers.impl_registers[CWND_REG] = state-&gt;pending_update.impl_registers[CWND_REG];</span><br><span class="line">    if (state-&gt;registers.impl_registers[CWND_REG] != 0) &#123;</span><br><span class="line">        datapath-&gt;set_cwnd(datapath, conn, state-&gt;registers.impl_registers[CWND_REG]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok = state_machine(conn);// 进入状态机</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//发送的消息格式</span><br><span class="line">    struct CreateMsg cr = &#123;</span><br><span class="line">        .init_cwnd = conn-&gt;flow_info.init_cwnd,</span><br><span class="line">        .mss = conn-&gt;flow_info.mss,</span><br><span class="line">        .src_ip = conn-&gt;flow_info.src_ip,</span><br><span class="line">        .src_port = conn-&gt;flow_info.src_port,</span><br><span class="line">        .dst_ip = conn-&gt;flow_info.dst_ip,</span><br><span class="line">        .dst_port = conn-&gt;flow_info.dst_port,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>4.4 进入machine.c ，分析state_machine函数。从connetciton中提取出state,从state中提取出program, 通过 process_expression()函数计算，将计算结果写入相关寄存器。 根据寄存器的结果，选择将相关的计算结果写入相应的地方。 即修改cwnd， rate_abs, 或者将测量结果通过函数 send_measurement（）发送给ccp的userspace。</p>
<ol>
<li>接下来分析一下kernel space 收到从user spcace中的消息时的行为：<br>定位 ccp.c, 函数 ccp_read_msg(),可以发现回传的消息类型有三种，具体可见文件libcpp/serialize.c/read_header函数， 分别为INSTALL_EXPR、UPDATE_FIELDS、CHANGE_PROG三种类型。<br>INSTALL_EXPR：INSTALL_EXPR message is for all flows, not a specific connection.<br>安装program, 执行datapath_program_install函数。<br>datapath_program_install函数: saves a new datapath program into the array of datapath programs； returns index into datapath program array where this program is stored； if there is no more space, returns -1； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Callback to pass to IPC for incoming messages.</span><br><span class="line"> * Cannot take ccp_connection as an argument, since it&apos;s a callback.</span><br><span class="line"> * Therefore, must look up ccp_connction from socket_id.</span><br><span class="line"> * buf: the received message, of size bufsize.</span><br><span class="line"> */</span><br><span class="line">int ccp_read_msg(</span><br><span class="line">    char *buf,</span><br><span class="line">    int bufsize</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分析测量结果的得出与汇报，从下面代码段可以看出，测量结果存在 report registers中，通过检测 SHOULD_REPORT_REG 标志来决定是否发送测量结果给ccp user space.<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (state-&gt;registers.impl_registers[SHOULD_REPORT_REG]) &#123;</span><br><span class="line">        send_measurement(conn, program-&gt;program_uid, state-&gt;registers.report_registers, program-&gt;num_to_return);</span><br><span class="line">        reset_state(state);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过分析位于 machine.c 文件中的一下两个函数，可以发现这两个函数通过寄存器间的运算来进行相关测量工作，测量依据为program。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int process_expression(int expr_index, struct ccp_priv_state *state, struct ccp_primitives* primitives);</span><br><span class="line">int process_instruction(int instr_index, struct ccp_priv_state *state, struct ccp_primitives* primitives)</span><br><span class="line">//其他</span><br><span class="line">struct Register &#123;</span><br><span class="line">    u8 type;</span><br><span class="line">    int index;</span><br><span class="line">    u64 value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Programe是通过user space下发过来的，前文已经分析了下发流程，给出program的结构：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*  Entire datapath program</span><br><span class="line"> *  a set of expressions (conditions)</span><br><span class="line"> *  a set of instructions</span><br><span class="line"> */</span><br><span class="line">struct DatapathProgram &#123;</span><br><span class="line">    u8 num_to_return;</span><br><span class="line">    u16 index; // index in array</span><br><span class="line">    u32 program_uid; // program uid assigned by CCP agent</span><br><span class="line">    u32 num_expressions;</span><br><span class="line">    u32 num_instructions;</span><br><span class="line">    struct Expression expressions[MAX_EXPRESSIONS];</span><br><span class="line">    struct Instruction64 fold_instructions[MAX_INSTRUCTIONS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Portus-控制平面，用户态-代码阅读"><a href="#Portus-控制平面，用户态-代码阅读" class="headerlink" title="Portus(控制平面，用户态) 代码阅读"></a>Portus(控制平面，用户态) 代码阅读</h3><h5 id="Portus-简介"><a href="#Portus-简介" class="headerlink" title="Portus 简介"></a><a href="https://github.com/ccp-project/portus" target="_blank" rel="noopener">Portus</a> 简介</h5><p>Portus is an implementation of a congestion control plane (CCP). It is a library that can be used to write new congestion control algorithms in user-space. Congestion control algorithm implementations live in independent crates which use this library for common functionality. Each algorithm crate provides a binary which runs a CCP with that algorithm activated.<br>注：<a href="https://docs.rs/portus/0.5.0/portus/" target="_blank" rel="noopener">Portus</a>已有相关文档可供参考   </p>
<h5 id="libccp-简介"><a href="#libccp-简介" class="headerlink" title="libccp 简介"></a><a href="https://github.com/ccp-project/libccp" target="_blank" rel="noopener">libccp</a> 简介</h5><p>Libccp is an implementation of the core functionality necsesary for a datapath to communicate with a CCP process. The datapath is responsible for providing a few callback functions for modifying state internal to the datapath (e.g. congestion window or packet pacing rate) and a few utility functions and libccp handles everything else. The instructions below detail all of the steps necessary to make a datapath CCP compatible.</p>
<h4 id="Reno算法在User-Space的实现"><a href="#Reno算法在User-Space的实现" class="headerlink" title="Reno算法在User Space的实现"></a>Reno算法在User Space的实现</h4><ol>
<li>文件定位: /src/reno.rs 该文件定义了 Reno算法类， 包括 set_cwnd increase reduction等函数；</li>
<li><p>/bin/src/reno.rs，该文件是Reno算法的入口，给出Reno算法的相关配置。调用公共运行接口运行reno算法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccp_generic_cong_avoid::start::&lt;Reno&gt;(ipc.as_str(), log, cfg);</span><br></pre></td></tr></table></figure>
</li>
<li><p>/src/bin_helper.rs, 分析start函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">start</span></span>&lt;T: GenericCongAvoidAlg&gt;(ipc: &amp;<span class="built_in">str</span>, log: slog::Logger, cfg: GenericCongAvoidConfig)</span><br><span class="line">        <span class="string">"netlink"</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">use</span> portus::ipc::netlink::Socket;</span><br><span class="line">            <span class="keyword">let</span> b = Socket::&lt;Blocking&gt;::new()</span><br><span class="line">                .map(|sk| BackendBuilder &#123;sock: sk&#125;)</span><br><span class="line">                .expect(<span class="string">"ipc initialization"</span>);</span><br><span class="line">            portus::run::&lt;_, GenericCongAvoid&lt;_, T&gt;&gt;(</span><br><span class="line">                b,</span><br><span class="line">                &amp;portus::Config &#123;</span><br><span class="line">                    logger: <span class="literal">Some</span>(log),</span><br><span class="line">                    config: cfg,</span><br><span class="line">                &#125;</span><br><span class="line">            ).unwrap();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>/src/lib.rs 文件， 分析run函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pub fn run&lt;I, U&gt;(backend_builder:         BackendBuilder&lt;I&gt;, cfg: &amp;Config&lt;I, U&gt;) -&gt; Result&lt;!&gt;</span><br><span class="line">fn run_inner&lt;I, U&gt;(backend_builder: BackendBuilder&lt;I&gt;, cfg: &amp;Config&lt;I, U&gt;, continue_listening: Arc&lt;atomic::AtomicBool&gt;)  -&gt; Result&lt;()&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定位 portus/src/ipc/netlink.rs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  use super::Blocking;</span><br><span class="line">impl super::Ipc for Socket&lt;Blocking&gt; &#123;</span><br><span class="line">    fn recv(&amp;self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt; &#123;</span><br><span class="line">        self.__recv(buf, nix::sys::socket::MsgFlags::empty())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn send(&amp;self, buf: &amp;[u8]) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">        self.__send(buf)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn close(&amp;self) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">        self.__close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件定位 ccp_generic_cong_avoid/src/lib.rs,以下代码给出了初始化时datapath向用户空间汇报测量结果的方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Ipc, A: GenericCongAvoidAlg&gt; GenericCongAvoid&lt;T, A&gt; &#123;</span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">install_datapath_interval</span></span>(&amp;<span class="keyword">self</span>, interval: time::Duration) -&gt; Scop&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">install_datapath_interval_rtt</span></span>(&amp;<span class="keyword">self</span>) -&gt; Scope &#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">install_ack_update</span></span>(&amp;<span class="keyword">self</span>) -&gt; Scope &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以下代码指明了用户空间收到测量结果时的反应:<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Ipc, A: GenericCongAvoidAlg&gt; CongAlg&lt;T&gt; <span class="keyword">for</span> GenericCongAvoid&lt;T, A&gt; &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">on_report</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, _sock_id: <span class="built_in">u32</span>, m: Report)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>中间分析， 到目前为止，已基本能掌握整个系统的工作流程，但是对于每个小模块的具体流程还有待梳理清楚。下面将着重分析几个子模块的工作流程。</li>
</ol>
<h4 id="CCP系统是如何实现测量的"><a href="#CCP系统是如何实现测量的" class="headerlink" title="CCP系统是如何实现测量的?"></a>CCP系统是如何实现测量的?</h4><p>即对于每一个测量元素（rtt,ack，loss等）是如何实现测量的，在ccp系统中，这些测量元素被称为primitives.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Primitive registers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ACK_BYTES_ACKED          0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ACK_BYTES_MISORDERED     1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ACK_ECN_BYTES            2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ACK_ECN_PACKETS          3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ACK_LOST_PKTS_SAMPLE     4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ACK_NOW                  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ACK_PACKETS_ACKED        6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ACK_PACKETS_MISORDERED   7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FLOW_BYTES_IN_FLIGHT     8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FLOW_BYTES_PENDING       9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FLOW_PACKETS_IN_FLIGHT   10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FLOW_RATE_INCOMING       11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FLOW_RATE_OUTGOING       12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FLOW_RTT_SAMPLE_US       13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FLOW_WAS_TIMEOUT         14</span></span><br></pre></td></tr></table></figure></p>
<p>定位函数 tcp_ccp.c 文件中的 load_primitives 函数。在这个函数中，给出了如何测量primitives, 其取决于重要的结构体 sock，需要详细分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">load_primitives</span><span class="params">(struct sock *sk, <span class="keyword">const</span> struct rate_sample *rs)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>上述函数的结构体来自于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_ccp_cong_control</span><span class="params">(struct sock *sk, <span class="keyword">const</span> struct rate_sample *rs)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>而上述函数来自于注册函数的接口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> <span class="title">tcp_ccp_congestion_ops</span> = &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    .cong_control = tcp_ccp_cong_control,<span class="comment">//cong_control 提供给tcp_ccp_cong_contro 需要的参数</span></span><br><span class="line">    	<span class="comment">//	...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们知道了测量primitives时用到的关键数据结构来自于内核。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/18/Portus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xingguo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian-Daye on the Way">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/Portus/" itemprop="url">Portus 源码阅读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T21:18:15+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Software/" itemprop="url" rel="index">
                    <span itemprop="name">Software</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/18/Portus/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/03/18/Portus/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Portus-源码阅读"><a href="#Portus-源码阅读" class="headerlink" title="Portus 源码阅读"></a>Portus 源码阅读</h3><h4 id="Rust-入门学习"><a href="#Rust-入门学习" class="headerlink" title="Rust 入门学习"></a>Rust 入门学习</h4><p>由于Portus是用Rust语言编写而成， 为了理清楚Portus的实现原理，需要了解Rust。发现了一个<a href="https://rustlang-cn.org/read/rust/2018/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARust-Future-Part-5.html" target="_blank" rel="noopener">Rust学习中文社区</a>，记录下来。关于<a href="https://github.com/ccp-project/portus" target="_blank" rel="noopener">Portus</a>源码的分析，过段时间会放到博客上来。<br>另外，<a href="https://github.com/ccp-project/ccp-kernel" target="_blank" rel="noopener">CCP在Linux Kernel</a>上的实现流程还在梳理中，等梳理清楚后会放到博客上来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/PI源码分析以及服务注入_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xingguo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian-Daye on the Way">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/PI源码分析以及服务注入_3/" itemprop="url">PI源码分析以及服务注入(3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-12T21:10:15+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Software/" itemprop="url" rel="index">
                    <span itemprop="name">Software</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/12/PI源码分析以及服务注入_3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/10/12/PI源码分析以及服务注入_3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="demo-grpc-server-端代码分析"><a href="#demo-grpc-server-端代码分析" class="headerlink" title="demo_grpc server 端代码分析"></a>demo_grpc server 端代码分析</h2><p>首先，需要说明的是在本项目中编译后端即目标交换机不是 bmv2, 使用 dummy交换机， 该交换机的所有相关代码都没有实现，需要开发者根据自己的目标交换机来实现具体的函数。</p>
<h3 id="函数入口"><a href="#函数入口" class="headerlink" title="函数入口"></a>函数入口</h3><p><font color="red">pi_server_main.cpp</font> 是整个server 端的入口。关键函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PIGrpcServerRunAddr(server_address);</span><br><span class="line">```    </span><br><span class="line">查看函数 &lt;font color=red&gt;<span class="keyword">void</span> PIGrpcServerRunAddr(<span class="keyword">const</span> <span class="keyword">char</span> *server_address)&lt;/font&gt;, 该函数位于 pi_server.cpp 文件中。该函数将会初始化整个服务器，包括绑定服务等等。下面将会分析P4runtime 提供的相关服务。在该文件中，类 P4RuntimeServiceImpl 实现了p4runtime 的服务。</span><br><span class="line">```cpp </span><br><span class="line">class P4RuntimeServiceImpl : <span class="keyword">public</span> p4v1::P4Runtime::Service &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="p4runtime-的服务函数包括："><a href="#p4runtime-的服务函数包括：" class="headerlink" title="p4runtime 的服务函数包括："></a>p4runtime 的服务函数包括：</h4><ol>
<li><p>Write 函数, </p>
<pre><code class="cpp"><span class="function">Status <span class="title">Write</span><span class="params">(ServerContext *context,</span></span>
<span class="function"><span class="params">            <span class="keyword">const</span> p4v1::WriteRequest *request,</span></span>
<span class="function"><span class="params">            p4v1::WriteResponse *rep)</span> override </span>{}
</code></pre>
<p>简介：Write 函数实现了 Write rpc服务，用作 client 向 server 端进行相关写操作。关键代码：</p>
<pre><code class="cpp"><span class="keyword">auto</span> device = Devices::get(request-&gt;device_id());<span class="comment">//根据device_id确定要访问的设备；</span>
...
<span class="keyword">auto</span> device_mgr = device-&gt;get_p4_mgr();<span class="comment">// 获取访问对象的 p4_mgr, 该 p4_mgr 由p4代码段生成的json文件配置而成。</span>
...
<span class="keyword">auto</span> status = device_mgr-&gt;write(*request);<span class="comment">// 将client端的request交由device_mgr， 由device_mgr进行相关处理。</span>
</code></pre>
</li>
<li><p>Read 函数</p>
<pre><code class="cpp"><span class="function">Status <span class="title">Read</span><span class="params">(ServerContext *context,</span></span>
<span class="function"><span class="params">           <span class="keyword">const</span> p4v1::ReadRequest *request,</span></span>
<span class="function"><span class="params">           ServerWriter&lt;p4v1::ReadResponse&gt; *writer)</span> override </span>{...}
</code></pre>
<p>简介： Read 函数实现了 p4runtime proto 中的 Read rpc 服务。用于从client端向server端读取信息。server端将转发请求给device_mgr,之后server端收到device_mgr的返回信息，然后在发送给client端:</p>
<pre><code class="cpp"><span class="keyword">auto</span> status = device_mgr-&gt;read(*request, &amp;response);
writer-&gt;Write(response);<span class="comment">//结果写回client端</span>
</code></pre>
</li>
<li>SetForwardingPipelineConfig 函数<pre><code class="cpp"><span class="function">Status <span class="title">SetForwardingPipelineConfig</span><span class="params">(</span></span>
<span class="function"><span class="params">   ServerContext *context,</span></span>
<span class="function"><span class="params">   <span class="keyword">const</span> p4v1::SetForwardingPipelineConfigRequest *request,</span></span>
<span class="function"><span class="params">   p4v1::SetForwardingPipelineConfigResponse *rep)</span> override </span>{...}
</code></pre>
简介： 该函数实现了 rpc SetForwardingPipelineConfig 服务<pre><code class="cpp"><span class="keyword">auto</span> device_mgr = device-&gt;get_or_add_p4_mgr();<span class="comment">// 获取或者重新分配给一个device_mgr给device；</span>
 <span class="keyword">auto</span> status = device_mgr-&gt;pipeline_config_set(
     request-&gt;action(), request-&gt;config()); <span class="comment">// 配置device_mgr</span>
</code></pre>
</li>
<li>GetForwardingPipelineConfig 函数<pre><code class="cpp"><span class="function">Status <span class="title">GetForwardingPipelineConfig</span><span class="params">(</span></span>
<span class="function"><span class="params">   ServerContext *context,</span></span>
<span class="function"><span class="params">   <span class="keyword">const</span> p4v1::GetForwardingPipelineConfigRequest *request,</span></span>
<span class="function"><span class="params">   p4v1::GetForwardingPipelineConfigResponse *rep)</span> override </span>{...}
</code></pre>
简介： 获取device的配置文件</li>
<li>StreamChannel 函数<pre><code class="cpp"><span class="function">Status <span class="title">StreamChannel</span><span class="params">(ServerContext *context,</span></span>
<span class="function"><span class="params">                    StreamChannelReaderWriter *stream)</span> override </span>{...}
</code></pre>
简介： 双向 stream rpc 服务。server端会根据从 request中解析出来的字段 update_case 来做出相应的决策。分析部分代码：<pre><code class="cpp"><span class="keyword">case</span> p4v1::StreamMessageRequest::kPacket:
 {
   <span class="keyword">if</span> (connection_status.connection == <span class="literal">nullptr</span>) <span class="keyword">break</span>;
   <span class="keyword">auto</span> device_id = connection_status.device_id;
   Devices::get(device_id)-&gt;process_packet_out(
       connection_status.connection.get(), request.packet());
 }
 <span class="keyword">break</span>;
</code></pre>
这段代码执行了packet_out 操作， 即将 client 端的packet发送到device设备上。</li>
</ol>
<h4 id="summery-for-server-services"><a href="#summery-for-server-services" class="headerlink" title="summery for server services"></a>summery for server services</h4><p>以上5个函数实现了所有server端提供的 rpc 服务。这5个函数也是在 p4runtime proto 中提前定义好的 rpc 服务。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/30/PI源码分析以及服务注入_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xingguo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian-Daye on the Way">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/PI源码分析以及服务注入_2/" itemprop="url">PI源码分析以及服务注入(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-30T12:08:56+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Software/" itemprop="url" rel="index">
                    <span itemprop="name">Software</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/30/PI源码分析以及服务注入_2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/30/PI源码分析以及服务注入_2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="P4-Runtime"><a href="#P4-Runtime" class="headerlink" title="P4 Runtime"></a>P4 Runtime</h2><p>P4 Runtime <a href="https://s3-us-west-2.amazonaws.com/p4runtime/docs/v1.0.0-rc2/P4Runtime-Spec.pdf" target="_blank" rel="noopener">Specification</a> has been released. P4 is a language for programming the data plane of network devices. The P4Runtime API is a control plane specification for controlling the data plane elements of a device or program defined by a P4 program.<br> The architecture can been seen below:<br><img src="/MY_images/p4runtime.PNG" alt="P4 Runtime Archtecture"><br><!-- <img src="C:\Users\Administrator\Desktop\SmartNIc\p4runtime.PNG" alt="" title="" width="500" height="400" /> --><br>From the figure, we can see P4runtime use grpc to link server and client, and in SDN archtecture, client reprensents controller and gRPC server represents switch client. P4 Runtime protocol is defined by protobuf.<br>so if we want to add some new feature to P4 Runtime we can just add some new service to P4runtime.proto or add some new protos to PI， then integrated new service to P4runtime. And I will introduce how to integrated a new simple service to PI at section <a href="#jump">demo_grpc analysis</a>.</p>
<h2 id="demo-grpc-analysis"><a href="#demo-grpc-analysis" class="headerlink" title="demo_grpc analysis"></a><span id="jump">demo_grpc analysis</span></h2><p>PI 提供了一个demo, 用来说明使用 P4runtime 进行控制器和交换机的通信。 demo_grpc 位于文件夹 PI/proto/demo_grpc/ 文件夹下。P4runtime proto 的定义位于 PI/proto/p4runtime/proto/p4 文件夹下。通过集成一个服务到PI框架下另外分析demo_grpc。</p>
<p>Step1: 将 Helloworld.proto 进行编译, 类似于编译p4runtime.proto, 这里通过修改Makefile.am来达到在编译p4runtime的同时编译helloworld.<br>具体方法： 修改 PI/Proto/ 下的 Makefile.am 文件。修改后变动的地方如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protos = \</span><br><span class="line"><span class="variable">$(abs_srcdir)</span>/p4/v1/helloworld.proto \</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">EXTRA_DIST = \</span><br><span class="line"><span class="variable">$(abs_srcdir)</span>/p4/v1/helloworld.proto \</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">proto_cpp_files = \</span><br><span class="line">cpp_out/p4/v1/helloworld.pb.cc \</span><br><span class="line">cpp_out/p4/v1/helloworld.pb.h \</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">proto_grpc_files = \</span><br><span class="line">grpc_out/p4/v1/helloworld.grpc.pb.cc \</span><br><span class="line">grpc_out/p4/v1/helloworld.grpc.pb.h \</span><br><span class="line">'''</span><br><span class="line">注： 向 $protos 中添加 proto 可以达到编译 proto 的目的； 向 $proto_cpp_files 和 proto_grpc_files 中添加  .cc .h 文件可以达到编译该文件的作用；</span><br></pre></td></tr></table></figure></p>
<p>Step2: 在 PI/ 目录下执行 make， 这样就可以得到相应的编译之后的文件， 在 PI/proto/cpp_out/p4/v1 下可以看到新增的编译的文件， 例如 helloworld.pb.cc, helloworld.pb.lo 文件等等。</p>
<p>Step3:在demo_grpc目录下将helloworld服务集成到该demo中去。可以发现， 该目录下有一个可执行问价 pi_server_dummy  的可执行文件，由pi_server_main.cpp文件生成，通过修改该文件及其相关文件来达到集成服务的目的。<br>pi_server_main.cpp, 关键代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PIGrpcServerRunAddr(server_address);</span><br></pre></td></tr></table></figure></p>
<p>pi_server.cpp 中有关于该函数的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PIGrpcServerRunAddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *server_address)</span> </span>&#123;</span><br><span class="line">  server_data = <span class="keyword">new</span> ::pi::server::ServerData();</span><br><span class="line">  server_data-&gt;server_address = <span class="built_in">std</span>::<span class="built_in">string</span>(server_address);</span><br><span class="line">  <span class="keyword">auto</span> &amp;builder = server_data-&gt;builder;</span><br><span class="line">  builder.AddListeningPort(</span><br><span class="line">    server_data-&gt;server_address, grpc::InsecureServerCredentials(),</span><br><span class="line">    &amp;server_data-&gt;server_port);</span><br><span class="line">  builder.RegisterService(&amp;server_data-&gt;pi_service);</span><br><span class="line">  builder.RegisterService(&amp;server_data-&gt;hello_service);<span class="comment">// 新增服务 helloworld</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_SYSREPO</span></span><br><span class="line">  server_data-&gt;gnmi_service = ::pi::server::make_gnmi_service_sysrepo();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  server_data-&gt;gnmi_service = ::pi::server::make_gnmi_service_dummy();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// WITH_SYSREPO</span></span></span><br><span class="line">  builder.RegisterService(server_data-&gt;gnmi_service.get());</span><br><span class="line">  builder.SetMaxReceiveMessageSize(<span class="number">256</span>*<span class="number">1024</span>*<span class="number">1024</span>);  <span class="comment">// 256MB</span></span><br><span class="line"></span><br><span class="line">  server_data-&gt;server = builder.BuildAndStart();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server listening on "</span> &lt;&lt; server_data-&gt;server_address &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析上述代码可以发现，该函数的主要作用是在server上开启服务，指定服务器的地址，创建 builder, 添加侦听端口，地址，无加密的通信方式，之后注册相关服务。关键数据结构 ServerData。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ServerData</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> server_address;</span><br><span class="line">  <span class="keyword">int</span> server_port;</span><br><span class="line">  P4RuntimeServiceImpl pi_service;</span><br><span class="line">  HelloworldServiceImpl hello_service;<span class="comment">//New added service</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;gnmi::gNMI::Service&gt; gnmi_service;</span><br><span class="line">  ServerBuilder builder;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Server&gt; server;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这里添加了新增的服务 hello_service。关于服务类型 HelloworldServiceImpl 在 pi_server.cpp 中实现了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloworldServiceImpl</span> :</span> <span class="keyword">public</span> helloworld::Greeter::Service &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Status <span class="title">SayHello</span><span class="params">(ServerContext* context, <span class="keyword">const</span> HelloRequest* request,</span></span></span><br><span class="line"><span class="function"><span class="params">                HelloReply* reply)</span>  </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">prefix</span><span class="params">(<span class="string">"Hello "</span>)</span></span>;</span><br><span class="line">  reply-&gt;set_message(prefix + request-&gt;name());</span><br><span class="line">  <span class="keyword">return</span> Status::OK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：关于该服务的相头文件需要加到该文件中，到目前为止，helloword服务已经集成到server中去了。</p>
<p>Step4：在client端中添加调用helloworld服务的函数。在该文件目录下，simple_router_mgr.cpp文件实现了client的相关调用函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> SimpleRouterMgr::test_func_txg1()&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">user</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">  HelloRequest request;</span><br><span class="line">  request.set_name(user);</span><br><span class="line"></span><br><span class="line">  HelloReply reply;</span><br><span class="line">  ClientContext context;</span><br><span class="line">  Status status = stub_-&gt;SayHello(&amp;context, request, &amp;reply);</span><br><span class="line">    <span class="comment">// Act upon its status.</span></span><br><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; status.error_code() &lt;&lt; <span class="string">": "</span> &lt;&lt; status.error_message()</span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析该函数，关键点在于 stub_-&gt;SayHello(&amp;context, request, &amp;reply); 其中 stub_是访问helloworld服务的stub， 在该demo中，访问 p4runtime服务的stub是 pi_stub_, 但是使用 pi_stub_ 访问不了helloworld服务。 为了能够在这里使用stub_， 需要提前声明stub_。在文件simple_router_mgr.h, SimpleRouter的成员变量有：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;p4::v1::P4Runtime::Stub&gt; pi_stub_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;helloworld::Greeter::Stub&gt; stub_;<span class="comment">// New added stub</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;StreamChannelSyncClient&gt; packet_io_client;</span><br></pre></td></tr></table></figure></p>
<p>在 simple_router_mgr.cpp中对hello_stub进行初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SimpleRouterMgr::SimpleRouterMgr(<span class="keyword">int</span> dev_id,</span><br><span class="line">                                 boost::asio::io_service &amp;io_service,</span><br><span class="line">                                 <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Channel&gt; channel)</span><br><span class="line">    : dev_id(dev_id), io_service(io_service),</span><br><span class="line">      pi_stub_(p4v1::P4Runtime::NewStub(channel)),</span><br><span class="line">      hello_stub_(helloworld::Greeter::NewStub(channel)),</span><br><span class="line">      packet_io_client(<span class="keyword">new</span> StreamChannelSyncClient(<span class="keyword">this</span>, channel)) &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  Step5:<br>  5.1 重新编译；<br>  5.2 启动server<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pi_server_dummy</span><br></pre></td></tr></table></figure></p>
<p>  5.3 启动client，在 app.cpp 中的 main 函数中调用  SimpleRouterMgr::test_func_txg1() 函数，相当于启动client 去访问server中的helloworld函数。<br>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./controller</span><br></pre></td></tr></table></figure></p>
<p>  至此，整个helloworld服务已经集成到PI框架下了，并且通过验证，结果是正确的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/PI源码分析以及服务注入_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xingguo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian-Daye on the Way">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/PI源码分析以及服务注入_1/" itemprop="url">PI源码分析以及服务注入(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-20T21:18:15+08:00">
                2018-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Software/" itemprop="url" rel="index">
                    <span itemprop="name">Software</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/20/PI源码分析以及服务注入_1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/20/PI源码分析以及服务注入_1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Introduction-to-PI"><a href="#Introduction-to-PI" class="headerlink" title="Introduction to PI"></a>Introduction to PI</h2><p>PI 是由 Barefoot 和 Google 合力打造的针对P4生态的一个开源框架，目前，该框架主要为 P4 生态下的软件交换机 bmv2 服务。我们知道 OpenFlow 协议，一种依赖于网络协议的编程协议。 而P4提出了独立于网络协议的编程生态。在 SDN 框架下，如何控制器和交换机的交互？目前非常成熟的技术是利用 OpenFlow 协议。但是， 在P4的生态下，OpenFlow 就显得心有余而力不足了。在P4生态下， P4runtime 用来进行控制器和交换机的通信。而 PI 是一个将控制器，交换机， P4runtime 集合到一起的框架。目前，在该框架下可以完成的事情：使用 bmv2交换机， 通过 CLI 接口在runtime时对 bmv2交换机进行控制。<br>从PI的整体框架上来说， 控制器（CLI)<--p4runtime-->中间层PI<----->后端系统<----->特定交换机。 如果用户想要使用P4runtime 控制自己的交换机，那么用必须自己完善相应的后端系统。 目前针对交换机 bmv2的整个系统链已经完成呢。在PI框架下可以见到相关的bmv2 后端系统的实现代码。<br>PI 源代码见 <a href="https://github.com/p4lang/PI" target="_blank" rel="noopener">https://github.com/p4lang/PI</a></-----></-----></--p4runtime--></p>
<h2 id="Install-PI"><a href="#Install-PI" class="headerlink" title="Install PI"></a>Install PI</h2><p>PI 的详细安装过程代码仓库中已经给出了，这里列出我在编译时遇到的几个麻烦的点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ques1:</span><br><span class="line">在执行configure 时的错误：</span><br><span class="line">checking for python version... 2.7</span><br><span class="line">checking for python platform... linux2</span><br><span class="line">checking for python script directory... $&#123;prefix&#125;/lib/python2.7/dist-packages</span><br><span class="line">checking for python extension module directory... $&#123;exec_prefix&#125;/lib/python2.7/dist-packages</span><br><span class="line">./configure: line 16188: syntax error near unexpected token `PROTOBUF,&apos;</span><br><span class="line">./configure: line 16188: `PKG_CHECK_MODULES(PROTOBUF, protobuf &gt;= 3.0.0)&apos;</span><br><span class="line">configure: error: ./configure failed for proto</span><br><span class="line"></span><br><span class="line">解决方法：</span><br><span class="line">sudo apt-get install pkg-config</span><br><span class="line">export PROTOBUF=/usr/local</span><br><span class="line">export PROTOC=&quot;$PROTOBUF/bin/protoc&quot;</span><br><span class="line">export PROTOBUF_LIBS=&quot;-L$PROTOBUF/lib -lprotobuf -D_THREAD_SAFE&quot;</span><br><span class="line">export PROTOBUF_CFLAGS=&quot;-I$PROTOBUF/include -D_THREAD_SAFE&quot; </span><br><span class="line"></span><br><span class="line">注意：执行完上述步骤之后重新开始执行 ./autogen.sh</span><br><span class="line"></span><br><span class="line">ques2:</span><br><span class="line">checking for boostlib &gt;= 1.54.0... yes</span><br><span class="line">checking whether the Boost::Thread library is available... yes</span><br><span class="line">configure: error: Could not find a version of the library!</span><br><span class="line"></span><br><span class="line">solved:   </span><br><span class="line">sudo apt-get install libboost-all-dev</span><br><span class="line">./configure --with-boost-libdir=？？？    </span><br><span class="line">如果实在ARM环境下： ./configure --with-boost-libdir=/usr/lib/arm-linux-gnueabihf/</span><br></pre></td></tr></table></figure></p>
<p>#外， PI代码仓库中有一个demo,位于 PI/proto/demo_grpc/, 如果在 configure 过程中指定 –with-bmv2, 那么该demo一定会编#； 如果不想与bmv2进行交互，如果系统中缺少 libmicrohttpd 插件，则不会进行编译并且不会报错， 如果系统中装有该插件，该demo #进行编译。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/12/simulator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xingguo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian-Daye on the Way">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/12/simulator/" itemprop="url">Using Qemu to Simulate ARM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-12T13:36:43+08:00">
                2018-09-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/12/simulator/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/12/simulator/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="How-to-use-qemu-to-build-an-ARM-simulator"><a href="#How-to-use-qemu-to-build-an-ARM-simulator" class="headerlink" title="How to use qemu to build an ARM simulator?"></a>How to use qemu to build an ARM simulator?</h1><h2 id="Download-the-source-code-of-qemu-from-github"><a href="#Download-the-source-code-of-qemu-from-github" class="headerlink" title="Download the source code of qemu from github:"></a>Download the source code of qemu from github:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://github.com/Xilinx/qemu.git    </span><br><span class="line">$ cd qemu</span><br></pre></td></tr></table></figure>
<p>The command above will by default clone the master branch of QEMU. This generally is ahead of the version of QEMU released with PetaLinux. This means it has improvements and new features compared to the released version, but is also is less thoroughly tested and could have unknown bugs. If you want to build the source that was used for the released version of QEMU, please checkout the appropriate tag instead of the master branch.<br>As of QEMU released with 2016.2 all tags created by Xilinx will be signed and verified by a valid PGP signature.    </p>
<h2 id="Install-Qemu-Linux-Dependencies"><a href="#Install-Qemu-Linux-Dependencies" class="headerlink" title="Install Qemu Linux Dependencies"></a>Install Qemu Linux Dependencies</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install libglib2.0-dev libgcrypt20-dev zlib1g-dev autoconf automake libtool bison flex</span><br></pre></td></tr></table></figure>
<p>QEMU also includes sub modules that will need to be checked out. Use the follow command to checkout the appropriate sub modules.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init dtc</span><br></pre></td></tr></table></figure></p>
<h2 id="Configuring-QEMU"><a href="#Configuring-QEMU" class="headerlink" title="Configuring QEMU"></a>Configuring QEMU</h2><p>QEMU must be configured to build on the Linux host. This can be accomplished using the following command line.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --target-list=&quot;aarch64-softmmu,microblazeel-softmmu&quot; --enable-fdt --disable-kvm --disable-xen</span><br></pre></td></tr></table></figure></p>
<h2 id="Building-QEMU"><a href="#Building-QEMU" class="headerlink" title="Building QEMU"></a>Building QEMU</h2><p>The following command line builds QEMU to run on the host computer.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p>
<h2 id="Download-Linux-kernel-amp-amp-devicetree"><a href="#Download-Linux-kernel-amp-amp-devicetree" class="headerlink" title="Download Linux kernel &amp;&amp; devicetree"></a>Download Linux kernel &amp;&amp; devicetree</h2><p>Download xilinx release image, version zynq 2016.4. From url <a href="http://www.wiki.xilinx.com/Zynq%202016.4%20Release" target="_blank" rel="noopener">http://www.wiki.xilinx.com/Zynq%202016.4%20Release</a> we can get file 2016.4-zc706-release.tar.zx, compress this file and we will get dtb &amp;&amp; uImage. Besides, we can produce our own devicetree and customed kernel.</p>
<h2 id="Download-Ubuntu-Filesystem"><a href="#Download-Ubuntu-Filesystem" class="headerlink" title="Download Ubuntu Filesystem"></a>Download Ubuntu Filesystem</h2><p>At this time, we choose a existed filesystem. From source <a href="https://rcn-ee.com/rootfs/eewiki/minfs/" target="_blank" rel="noopener">https://rcn-ee.com/rootfs/eewiki/minfs/</a>  we download file ubuntu-16.04.4-minimal-armhf-2018-03-26.tar.xz. Compress the file and we will get the rootfs x.tar. </p>
<h2 id="Make-a-startup-disk"><a href="#Make-a-startup-disk" class="headerlink" title="Make a startup disk"></a>Make a startup disk</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=ubuntu.ext4 <span class="comment"># produce a file named ubuntu.ext4</span></span><br><span class="line">mkfs.ext4 ubuntu.ext4 <span class="comment"># Format ubuntu.ext4</span></span><br><span class="line">sudo mkdir -p /mnt/rootfs <span class="comment"># make a dir /mnt/rootfs</span></span><br><span class="line">sudo mount ubuntu.ext4 /mnt/rootfs <span class="comment"># mount ubuntu.ext4 to /mnt/rootfs</span></span><br><span class="line">sudo tar x.tar -C /mnt/rootfs/</span><br><span class="line">sync <span class="comment"># </span></span><br><span class="line">sudo chown root:root /mnt/rootfs/</span><br><span class="line">sudo chmod 755 /mnt/rootfs  </span><br><span class="line">sudo umount /mnt/rootfs</span><br></pre></td></tr></table></figure>
<h2 id="Start-Up-Qemu"><a href="#Start-Up-Qemu" class="headerlink" title="Start Up Qemu"></a>Start Up Qemu</h2><p> In the file qemu, excute the following command<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./aarch64-softmmu/qemu-system-aarch64  </span><br><span class="line">-M arm-generic-fdt-7series -machine linux=on</span><br><span class="line">-serial /dev/null -serial mon:stdio -display none</span><br><span class="line">-kernel ../project/2016.4-zc706-release/zc706/uImage</span><br><span class="line">-dtb ../project/2016.4-zc706-release/zc706/my.dtb</span><br><span class="line">-sd ../project/ubuntu.ext4</span><br><span class="line">-append &apos;root=/dev/mmcblk0 rw rootwait console=ttyPS0 devtmpfs mount=0&apos;</span><br></pre></td></tr></table></figure></p>
<p> Anoter way to start qemu:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ./aarch64-softmmu/qemu-system-aarch64  </span><br><span class="line">-M arm-generic-fdt-7series -machine linux=on</span><br><span class="line">-serial /dev/null -serial mon:stdio -display none</span><br><span class="line">-kernel ../project/2016.4-zc706-release/zc706/uImage</span><br><span class="line">-dtb ../project/2016.4-zc706-release/zc706/my.dtb</span><br><span class="line">-drive if=sd,cache=writeback,file=../project/ubuntu.ext4</span><br><span class="line">-append &apos;root=/dev/mmcblk0 rw rootwait console=ttyPS0 devtmpfs mount=0&apos;</span><br></pre></td></tr></table></figure></p>
<p> Anotations  below to specify the meanings of the arguments:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># qemu-system-aarch64</span><br><span class="line"># -M</span><br><span class="line"># -serial</span><br><span class="line"># -kernel</span><br><span class="line"># -dtb</span><br><span class="line"># -drive</span><br><span class="line"># -append</span><br></pre></td></tr></table></figure></p>
<h2 id="Standard-Arguments-Required"><a href="#Standard-Arguments-Required" class="headerlink" title="Standard Arguments Required"></a>Standard Arguments Required</h2><p> The standard arguments to startup qemu can been seen @: <a href="https://qemu.weilnetz.de/doc/qemu-doc.html#pcsys_005fquickstart" target="_blank" rel="noopener">https://qemu.weilnetz.de/doc/qemu-doc.html#pcsys_005fquickstart</a></p>
<p> Reference: <a href="http://www.wiki.xilinx.com/QEMU" target="_blank" rel="noopener">Xilinx Qemu Wiki</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/06/Test-my-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xingguo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian-Daye on the Way">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/06/Test-my-blog/" itemprop="url">Test my blog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T21:18:15+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hardware/" itemprop="url" rel="index">
                    <span itemprop="name">Hardware</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/06/Test-my-blog/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/06/Test-my-blog/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="硬件启动过程"><a href="#硬件启动过程" class="headerlink" title="硬件启动过程"></a>硬件启动过程</h1><h3 id="下面将会以图片的格式来说明如何利用脚本文件生成相应的文件"><a href="#下面将会以图片的格式来说明如何利用脚本文件生成相应的文件" class="headerlink" title="下面将会以图片的格式来说明如何利用脚本文件生成相应的文件"></a>下面将会以图片的格式来说明如何利用脚本文件生成相应的文件</h3><p><img src="/MY_images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171116142955.jpg" alt="step1"></p>
<p><img src="/MY_images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171116143008.jpg" alt="step2"></p>
<p><img src="/MY_images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171116143021.jpg" alt="step3"></p>
<p><img src="/MY_images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171116143027.jpg" alt="step4"></p>
<p><img src="/MY_images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171116143035.jpg" alt="step5"></p>
<p><img src="/MY_images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171116143059.jpg" alt="step6"></p>
<p><img src="/MY_images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171116143051.jpg" alt="step7"></p>
<p><img src="/MY_images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171116143105.jpg" alt="step8"></p>
<p><img src="/MY_images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171116143111.jpg" alt="step9"></p>
<h1 id="软件启动过程"><a href="#软件启动过程" class="headerlink" title="软件启动过程"></a>软件启动过程</h1><h2 id="Xilinx-ZYNQ7045-通过-MMC-启动过程"><a href="#Xilinx-ZYNQ7045-通过-MMC-启动过程" class="headerlink" title="Xilinx ZYNQ7045 通过 MMC 启动过程"></a>Xilinx ZYNQ7045 通过 MMC 启动过程</h2><ul>
<li>boot.scr 文件<ul>
<li>u-boot在启动的时候会在第一个分区（FAT/extX格式）寻找/boot.scr或者/boot/boot.scr文件，boot.scr中可以包含用于载入 devicetree.dtb，kernel，initrd（可选）以及设置内核启动参数的uboot命令。所以boot.scr相当于是一个启动脚本文件，处理器会根据该文件设置相关的环境，加载相关的文件到指定的内存位置。</li>
</ul>
</li>
<li><p>boot.scr 文件的生成       </p>
<pre><code>bootscript = mkimage -A arm -O linux -T script -C none -a 0 -e 0 -n &quot;Uboot mmc start script&quot; -d bscripts/mmcboot-rootfs bscripts/uboot.scr
 # 相关参数的含义可以见网站(http://forum.lemaker.org/cn/forum.php?mod=viewthread&amp;tid=62&amp;page=)
 # 其中mmc-boots作为相输入文件，根据该输入文件生成输出文件
</code></pre></li>
<li><p>mmboot-rootfs  </p>
<pre><code> run mmc_args &amp;&amp; mmc rescan &amp;&amp; load mmc 0 ${kernel_loadaddr} ${kernel_image} &amp;&amp; load mmc 0 ${devicetree_loadaddr} ${devicetree_image} &amp;&amp; run setupqspi &amp;&amp; bootm ${kernel_loadaddr} - ${devicetree_loadaddr}
# 该输入文件指定了加载文件以及加载地址
</code></pre></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/06/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xingguo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian-Daye on the Way">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/06/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T19:49:07+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/06/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/06/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Xingguo</p>
              <p class="site-description motion-element" itemprop="description">To share something Useful and Meaningful Located in MY mind</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/XingguoTian" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xingguo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://https-xingguotian-github-io.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
